#!/usr/bin/expect -f
set timeout -1

# ---------- Ask user for inputs ----------
proc ask_user {prompt} {
    puts -nonewline $prompt
    flush stdout
    expect_user -re "(.*)\n"
    return [string trim $expect_out(1,string)]
}

set store_num [ask_user "Enter JITB Store Number: "]
set qu_num    [ask_user "Enter Qu Store ID: "]
set dev_id    [ask_user "Enter Qubox Terminal ID: "]

if {![string is integer -strict $store_num]} {
    puts "ERROR:JITB Store Number must be an integer."
    exit 1
}
# dev_id might be numeric; if it isn't, IP last octet will be invalid. Warn, but proceed.
if {![string is integer -strict $dev_id]} {
    puts "WARNING: Qubox Terminal ID is not an integer. IP last octet may be invalid."
}

# ---------- Compute device name ----------
set device_name "c405s${qu_num}d${dev_id}"
puts "Computed DEVICE_NAME: $device_name"

# ---------- Compute IP from store_num + dev_id ----------
# matches your formula (bc not needed in Tcl)
set first_octet  "10"
set second_octet [expr {int($store_num / 256) + 130}]
set third_octet  [expr {$store_num % 256}]
set last_octet   "9"
set ip_address "${first_octet}.${second_octet}.${third_octet}.${last_octet}"

puts "Computed IP_ADDRESS: $ip_address"

# Write a runtime env file (optional but handy for auditing)
set runtime_file "./device.runtime.env"
set fp [open $runtime_file "w"]
puts $fp "STORE_NUMBER=$store_num"
puts $fp "QU_NUMBER=$qu_num"
puts $fp "DEVICE_ID=$dev_id"
puts $fp "DEVICE_NAME=$device_name"
puts $fp "IP_ADDRESS=$ip_address"
close $fp
puts "Wrote runtime values to $runtime_file"

# ---------- Docker wait helper ----------
proc wait_for_dockers {min_count name_pattern} {
    while {1} {
        set total_str [exec sh -c "docker ps -q | wc -l"]
        set total [string trim $total_str]

        set names_output [exec sh -c "docker ps --format '{{.Names}}' 2>/dev/null || true"]
        set names [split $names_output "\n"]

        set have_match 0
        foreach n $names {
            if {$n eq ""} { continue }
            if {[string match $name_pattern $n]} {
                set have_match 1
                break
            }
        }

        puts "Docker status: $total containers, match=$have_match (pattern: $name_pattern)"

        if {[string is integer -strict $total] && $total >= $min_count && $have_match} {
            puts "Docker requirement satisfied."
            break
        }

        sleep 50
    }
}

# ---------- (Optional) Set hostname early ----------
# If your environment supports it and you want OS hostname to match:
# exec sudo hostnamectl set-hostname $device_name

# ---------- Step 1: Download ecs-registration.sh ----------
puts "\n=== Downloading ecs-registration.sh ==="
# Safer curl proto restriction form:
spawn sudo curl --proto "=https" -o ecs-registration.sh https://qu-releases.qubeyond.com/qubox/ecs-registration.sh
expect eof

puts "\n=== chmod +x ecs-registration.sh ==="
spawn sudo chmod +x ecs-registration.sh
expect eof

# ---------- Step 2: Run ecs-registration.sh and answer prompts ----------
puts "\n=== Running ecs-registration.sh ==="
spawn sudo ./ecs-registration.sh

# Device name prompts
expect -re {Do you want to set a different device name\?\s*\(y/n\)} { send "y\r" }
expect -re {Please enter a name to identify this device.*}         { send "$device_name\r" }

# Purple enter
puts "Purple screen"
# expect -re {Purple screen popup.*\[enter\]} { send "\r" }

# Static IP choice -> NO (because we computed an IP, and it will be updated later using correct_cidr.py)
expect -re {Do you want to set a static ip address\?\s*\(y/n\)} { send "n\r" }

expect eof
puts "\n=== ecs-registration.sh finished ==="

# ---------- Step 3: Wait for docker readiness ----------
puts "\n=== Waiting for 10 containers and traefik ==="
wait_for_dockers 10 "ecs-qu-box-prod-*-traefik-*"
puts "\n=== Dockers are loaded ==="

# ---------- Step 4: Run /home/qu/activate.sh and capture GUID ----------
puts "\n=== Running /home/qu/activate.sh and capturing GUID ==="
spawn bash /home/qu/activate.sh

set guid ""

# GUID pattern: 6 groups of 4 alnum separated by 5 dashes
# Example: 66be-3c3a-5647-9387-c0c4-1890
expect {
    -re {([A-Za-z0-9]{4}(?:-[A-Za-z0-9]{4}){5})} {
        set guid $expect_out(1,string)
        puts "\n Captured GUID: $guid"
        exp_continue
    }
    -re {[Pp]ress.*[Ee]nter|[Hh]it.*[Ee]nter|\[enter\]} {
        puts "\n*** PAUSED: Complete activation work on EI, then press Enter here to continue ***"
        flush stdout
        expect_user -re "(.*)\n"
        send "\r"
        exp_continue
    }
    eof { }
}

if {$guid eq ""} {
    puts "WARNING: No GUID captured."
} else {
    # Append GUID to the runtime env file
    set gfp [open $runtime_file "a"]
    puts $gfp "ACTIVATION_GUID=$guid"
    close $gfp
    puts "Wrote GUID to $runtime_file"
}

# ---------- Step 5: Configure IP directly ----------
# ethernets value should be enp0s31f6 but it was eno1 in tests, hardcoding the value for now.
# considering all devices will be the same model.
puts -nonewline "\n=== continue with IP configuration? (y/n): "
flush stdout
expect_user -re "(.*)\n"
set ready_ip [string tolower [string trim $expect_out(1,string)]]

if {$ready_ip eq "y" || $ready_ip eq "yes"} {
    puts "\n=== Configuring static IP address ==="
    
    # Calculate gateway (assuming .30 in the same subnet)
    set gateway "${first_octet}.${second_octet}.${third_octet}.30"
    
    # Add /27 CIDR to IP
    set ip_with_cidr "${ip_address}/27"
    
    puts "IP Address: $ip_with_cidr"
    puts "Gateway: $gateway"
    
    # Get NIC name from existing netplan config
    set nic_cmd "grep -A1 'ethernets:' /etc/netplan/01-netcfg.yaml | tail -1 | awk '{print \$1}' | tr -d ':'"
    set nic_name [exec sh -c $nic_cmd]
    # should be enp0s31f6 but it was eno1 hardcoding the value for now
    set nic_name [string trim $nic_name]
    set nic_name "enp0s31f6"
    puts "Network Interface: $nic_name" 
    
    # Create netplan configuration
    set netplan_config "network:\n  version: 2\n  renderer: networkd\n  ethernets:\n    ${nic_name}:\n      dhcp4: no\n      addresses:\n        - ${ip_with_cidr}\n      gateway4: ${gateway}\n      nameservers:\n        addresses: \[10.104.48.31, 10.104.48.32, 10.104.48.33, 10.95.128.31, 10.95.128.5\]"
    
    # Write to temp file then move to final location
    set temp_file "/tmp/netplan_temp.yaml"
    set fp [open $temp_file "w"]
    puts $fp [exec echo -e $netplan_config]
    close $fp
    
    # Move to netplan directory
    exec sudo mv $temp_file /etc/netplan/01-netcfg.yaml
    exec sudo chmod 600 /etc/netplan/01-netcfg.yaml
    
    puts "\n=== Netplan configuration updated ==="
    puts "To apply: sudo netplan apply"
} else {
    puts "Skipping IP configuration."
}
# ---------- Step 6: timeadjustments ----------
# other options? hawaii, alaska, etc.
puts "\n=== System Time Zone Configuration ==="
puts "Please select a timezone:"
puts "1) US/Eastern"
puts "2) US/Central"
puts "3) US/Mountain"
puts "4) US/Pacific"
puts -nonewline "Enter your choice (1-4): "
flush stdout
expect_user -re "(.*)\n"
set tz_choice [string trim $expect_out(1,string)]

switch $tz_choice {
    "1" {
        set timezone "US/Eastern"
    }
    "2" {
        set timezone "US/Central"
    }
    "3" {
        set timezone "US/Mountain"
    }
    "4" {
        set timezone "US/Pacific"
    }
    default {
        puts "Invalid choice. Skipping timezone configuration."
        set timezone ""
    }
}

if {$timezone ne ""} {
    puts "\n=== Setting timezone to $timezone ==="
    spawn sudo timedatectl set-timezone $timezone
    expect eof
    puts "Timezone set successfully."
}

# ---------- Step 7: Install BigFix ----------
puts -nonewline "\n=== continue with BigFix installation? (y/n): "
flush stdout
expect_user -re "(.*)\n"
set ready_bigfix [string tolower [string trim $expect_out(1,string)]]

if {$ready_bigfix eq "y" || $ready_bigfix eq "yes"} {
    puts "\n=== Begin BigFix Installation ==="
    
    # Create installation directory
    puts "Creating BESClient directory..."
    spawn sudo mkdir -v /etc/opt/BESClient
    expect eof
    
    # Download masthead
    # Edgar found that we needed to rename the masthead.afxm to actionsite.afxm.
    puts "Download Masthead - 25% Complete"
    spawn sudo wget http://epmanp.jackinthebox.com:52311/masthead/masthead.afxm -O /etc/opt/BESClient/actionsite.afxm
    expect eof
    
    # Download BigFix Agent
    puts "Download BigFix Agent - 50% Complete"
    spawn sudo wget https://software.bigfix.com/download/bes/110/BESAgent-11.0.4.60-ubuntu18.amd64.deb -O /etc/opt/BESClient/BESAgent-11.0.4.60-ubuntu18.amd64.deb
    expect eof
    
    # Change permissions
    puts "Change permissions - 75% Complete"
    spawn sudo chmod -R 777 /etc/opt/BESClient
    expect eof
    
    # Install BES Agent
    puts "Install BigFix - 90% Complete"
    spawn sudo dpkg -i /etc/opt/BESClient/BESAgent-11.0.4.60-ubuntu18.amd64.deb
    expect eof
    
    # Verify service is running
    puts "Verify Service is running - 100% Complete"
    spawn sudo systemctl status besclient --no-pager
    expect eof
    
    puts "Verify completed - Please take a picture for documentation"
    spawn ps -ef
    expect eof
    
    puts "\n=== BigFix installation completed ==="
} else {
    puts "Skipping BigFix installation."
}

puts "\n=== Done (interactive run) ==="
#what a day



exit 0
